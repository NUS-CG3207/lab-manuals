# Lab 4: (Near) Complete Processor + Pipelining + Bells + Whistles

Lab 4 involves **2 compulsory tasks** and the rest is **open-ended.**

Demonstrate \[Post-synthesis simulation and FPGA hardware\] incorporating all the mandatory and open-ended parts. Use a single assembly program that can be entirely compiler-generated, entirely hand-crafted, or a combination of the two.

## Compulsory Task 1 \[5 marks\]

Add support for the following previously unsupported instructions/features mentioned below. They are pretty easy to add at this point and will allow you to run almost all the code generated by a compiler such as https://godbolt.org/.

There is no need to try and craft a program specifically to demonstrate everything below. The only requirement is to have at least one function call in your program, which will cause `jal` (`call`) and `jalr` (`ret`) to be emitted by the compiler.

* DP instructions: `xor`, `xori`, `slt`, `sltu`, `slti`, `sltiu`, `slli`, `srli`, `srai`. 

* Branch instructions: `blt`, `bge`, `bltu`, `bgeu`, `jal` (with support for linking: i.e. `rd = PC + 4`), `jalr`.
  
* Multiply (M) instructions: `mulh`, `mulhu`, `mulhsu`, `div`, `rem`, `remu`.

Note: Support for byte and half-word load / store is not a basic requirement. They can be mostly avoided by using only `int`s in your program. However, incorporating them can lead to easier to write and more efficient programs, especially when using byte-oriented peripherals such as the UART CONSOLE.

## Compulsory Task 2 \[10 marks\]

Implement basic pipelining. Hazard hardware is optional and will count as an open-ended enhancement if done, but it is not counted for the compulsory task marks. The pipelining should be done such that the processor supports all the requirements for Lab 2, Lab 3, and the additional instructions / features mentioned in Lab 4 Compulsory Task 1 mentioned above.

As long as your code works after inserting the sufficient `NOP`s, this task requirement can be satisfied. If you have full hazard hardware, of course, `NOP`s are unnecessary. 

For some tips on implementing pipelining, [see this page](pipeline.md).

## Open-ended Enhancement \[10 marks\]

This is the fun part - you get 10 marks for Lab 4 for implementing performance enhancements of your choice. There is no fixed requirement to get these marks, and while we suggest some enhancements below, it doesn't mean you need to implement all (or any!) of these. Just one significant performance enhancement will suffice, and this need not be limited to the ones we have listed. 

Some potential improvements you can think about implementing are:

* [Implement hazard detection and resolution](hazard.md)
* [Implement additional instructions](additional_instructions.md)
* [Implement exception handling and interrupt support](interrupts.md)


## Design Instructions

*   You are encouraged to have your own, comprehensive programs to have a convincing demo.
*   You may have to tweak the templates given in Lab 2 for use in Lab 4. Specifically, you will have to change the ALUControl to 4 bits for ARM.
*   All 32-bit combinational arithmetic and logical operations have to be performed inside the ALU. *Exceptions*: `+` for calculating `PC+4`, `PC+8`, multiplication, division, enhancements such as branch prediction. Pipeline hazard detection will require comparisons (for equality only) too, but they are on 5-bit values.
*   In the ALU, DO NOT use additional `+` signs -> this could infer additional adders. The existing addition framework should be good enough.
*   All operators are permitted on 32-bit values outside the ARM/RISC-V module. For example, you will have to do 32-bit comparisons in the wrapper for address decoding.
*   Use of arithmetic operators  
    1.  Do not use `*` operator. It is synthesizable, but in this course, we are implementing multi-cycle multiplication. `/` is not synthesizable, except on constants.
    2.  All operators (including `**`, `*`, `/`, `sll`, `rem`, `mod` etc.) are allowed on constants (operations on constants are done at synthesis time, and will not infer any hardware).

## Submission Info

*   Lab 4 will be evaluated in **Week 12**. The presentation schedule can be found on Canvas. 
*   Include
    
    *   **.v/vhd** files you have created/modified \[ RTL Sources, Testbench(es) \] 
    *   **.bit** files 
    *   **.s/.asm** files (assembly programs)
    *   **.ppt** file - 2 to 6 slides showing performance enhancement techniques you have implemented.
    
    in an archive with the filename **GroupXX****\_Monday/Friday\_Lab4.zip** (replace XX with your group number) and upload it to Canvas. One submission per group is sufficient – if there are multiple submissions, the file with the latest timestamp will be taken as the final submission. **_Do not_** zip and upload the complete project folder – only those files mentioned above should be included. **The files should be the exact same files that you used for the demo.**
