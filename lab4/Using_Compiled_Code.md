
# Using Compiled Code and New Peripherals

## Using Compiled Code

It is strongly recommended to use the new template files at https://github.com/NUS-CG3207/lab-skeletons/tree/main/lab2/V3 .


* To the extent possible, it is a good idea to test your algorithms (e.g., masking and shifts to deal with bytes within a word.) in a standard C compiler, making appropriate changes (e.g., printf and scanf/hardcoding to simulate actual system input and output) to run in a desktop environment.
* Godbolt [Settings](godbolt.png) can be seen here.
* Do not use library functions such as printf.Â 
* Make sure that only those supported by your processor are generated. Check in RARS execute window for actual instructions.
* The only essential change needed for the assembly code generated by godbolt is to have a .data inserted just before the data declarations.
* Check the actual number of instructions (not lines of code as some instructions are pseudoinstructions). Make sure the size is set in HDL IROM_DEPTH_BITS as appropriate. e.g., should be 10 if the number of instructions is >128 and <=255.
* DMEM_DEPTH_BITS should also be changed as appropriate. It should be 10 for using the original peripheral addresses in the previous versions of the wrapper (as the DROM+DRAM is 256 words). However, if you need more memory (DRAM+DROM), change this. STACK_INIT and MMIO_BASE in your C source code should also be modified to correspond to this.
    * Stack pointer is set to point to the top of RAM initially (STACK_INIT). Stack is full-descending, so the first value is pushed to STACK_INIT-4.
* Make sure the correct memory config is selected in RARS.
* The first few instrucions that save the callee saved registers to the stack can be deleted safely. There is no caller for main().
* Make sure the main function code is at the beginning. Some compilers such as gcc may put this in the end, in which case you need to rearrange the functions in assembly. Our absolute baremetal system do not have a linker/loader/startup code to start at main if it is not in the beginning.
* Simulate the code in RARS.
    * When using memory mapped input peripherals, the corresponding address location should be modified just before the corresponding lw is executed to simulate the data coming in from peripherals.
    * If you are using the counter peripheral for delay, you might want to use a smaller delay for simulation, and change the code to a bigger value later. This can be changed in C code or directly in assembly (likely lui)
    * Though you cant see OLED output, it is fairly easy to check the row, column, pixel colour, and pixel write signals and get a sense.
* Simulate in HDL behavioural sim, after changing the test_Wrapper to give stimuli according to the inputs expected by your program.
* Finally, synthesise and generate bitstream. Fingers crossed :)

## Using New Peripherals

The new peripherals cycle counter, accelerometer, and OLED display peripheral register info can be found in the Wrapper HDL code. 

### OLED
OLED uses PMOD B.

OLED_CTRL[3:0]
Change that triggers a write. We can vary one of them (e.g., column) while keeping the other two the same. This can be efficient like in the example program, where a line with a specified colour is drawn with the same colour and y, varying only x. 
* 0x0: vary_pixel_data_mode
* 0x1: vary_COL_mode (x)
* 0x2: vary_ROW_mode (y)
OLED_CTRL[7:4]
* 0x0: 7-bit colour mode: 1 byte per pixel, memory efficient especially if loading bitmapped images 0-2R-3G-2B format
* 0x1: 16-bit colour mode: Highest colour depth supported by the OLED in a compact representation. OLED native input format. 5R-6G-5B format.
* 0x2: 24-bit colour mode: Similar to standard displays, but some LSBs are not used. Easy to see in simulation. Wrapper output format. 5R-3(0)-6G-2(0)-5B-3(0) format.


### Cycle Counter
Cycle counter gives the number of processor cycles elapsed since the last reset.
Cycle counter rolls over at 42 seconds at 100 MHz (CLK_DIV_BITS = 0), but is much longer at lower frequnceies. 
Change counter width and bits used in Wrapper.v for a longer duration, but lower cycles precision.

### Accelerometer
Accelerometer gives the temperature as well as X, Y, Z accelerations.
ACCEL_DATA is a 32-bit value packing 4 independent 8-bit values <temperature, X, Y, Z> MSB downto LSB.
Each value is in 8-bit signed format with a range of +/- 2g. So a reading of 1g is 0x40 and -1g is 0xC0. 
Actually the sensor gives 12 bit reading, but using only 8 bits for simplicity. 

If you want only a specific axis or temperature, use a combination of logical operators and shift e.g., extract Y using (*ACC_DATA_ADDR & 0x0000FF00) >> 8. If your processor can do `lbu`, the required byte can be read directly.

ACCEL_DREADY indicates data readiness, which is useful only when attempting to read at a high rate.